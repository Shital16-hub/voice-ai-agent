
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Recognition Test</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        #status { margin: 10px 0; padding: 10px; background-color: #f0f0f0; }
        #transcript { margin: 10px 0; padding: 10px; min-height: 200px; border: 1px solid #ccc; }
        button { padding: 10px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Real-time Speech Recognition Test</h1>
    <div>
        <button id="startBtn">Start Recording</button>
        <button id="stopBtn" disabled>Stop Recording</button>
    </div>
    <div id="status">Status: Idle</div>
    <div>
        <h3>Transcript:</h3>
        <div id="transcript"></div>
    </div>

    <script>
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const transcriptDiv = document.getElementById('transcript');
        
        let socket;
        let mediaRecorder;
        let audioContext;
        let stream;
        
        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        
        async function startRecording() {
            try {
                statusDiv.textContent = 'Status: Connecting...';
                
                // Connect to WebSocket
                const serverUrl = window.location.hostname;
                const serverPort = window.location.port;
                const wsUrl = `ws://${serverUrl}:${serverPort}/ws/transcribe`;
                
                socket = new WebSocket(wsUrl);
                
                socket.onopen = async () => {
                    // Send configuration
                    const config = {
                        language: 'en',
                        sample_rate: 16000
                    };
                    socket.send(JSON.stringify(config));
                    
                    // Wait for ready message
                    socket.onmessage = async (event) => {
                        const data = JSON.parse(event.data);
                        
                        if (data.status === 'ready') {
                            // Start audio recording
                            statusDiv.textContent = 'Status: Recording...';
                            transcriptDiv.textContent = '';
                            
                            // Get user media
                            stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            
                            // Create audio context
                            audioContext = new AudioContext({
                                sampleRate: 16000
                            });
                            
                            // Create source node
                            const source = audioContext.createMediaStreamSource(stream);
                            
                            // Create processor node
                            const processor = audioContext.createScriptProcessor(4096, 1, 1);
                            
                            // Connect nodes
                            source.connect(processor);
                            processor.connect(audioContext.destination);
                            
                            // Process audio data
                            processor.onaudioprocess = (e) => {
                                const inputData = e.inputBuffer.getChannelData(0);
                                
                                // Convert to 16-bit PCM
                                const pcmData = new Int16Array(inputData.length);
                                for (let i = 0; i < inputData.length; i++) {
                                    pcmData[i] = Math.max(-1, Math.min(1, inputData[i])) * 0x7FFF;
                                }
                                
                                // Send to WebSocket if connected
                                if (socket.readyState === WebSocket.OPEN) {
                                    socket.send(pcmData.buffer);
                                }
                            };
                            
                            // Update button state
                            startBtn.disabled = true;
                            stopBtn.disabled = false;
                            
                            // Update message handler
                            socket.onmessage = handleMessage;
                        }
                    };
                };
                
                socket.onerror = (error) => {
                    statusDiv.textContent = `Status: Error - ${error}`;
                    console.error('WebSocket error:', error);
                };
                
                socket.onclose = () => {
                    statusDiv.textContent = 'Status: Disconnected';
                    stopRecording();
                };
            } catch (error) {
                statusDiv.textContent = `Status: Error - ${error.message}`;
                console.error('Error starting recording:', error);
            }
        }
        
        function stopRecording() {
            // Stop media tracks
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            // Close audio context
            if (audioContext) {
                audioContext.close();
            }
            
            // Close WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.close();
            }
            
            // Update button state
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            statusDiv.textContent = 'Status: Idle';
        }
        
        function handleMessage(event) {
            const data = JSON.parse(event.data);
            
            if (data.type === 'transcription') {
                // Update transcript
                if (data.text) {
                    const p = document.createElement('p');
                    p.textContent = `[${data.start_time.toFixed(1)}s-${data.end_time.toFixed(1)}s] ${data.text}`;
                    transcriptDiv.appendChild(p);
                    transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
                }
            } else if (data.type === 'final') {
                statusDiv.textContent = `Status: Completed (${data.duration.toFixed(1)}s)`;
            } else if (data.type === 'error') {
                statusDiv.textContent = `Status: Error - ${data.message}`;
                console.error('Transcription error:', data.message);
            }
        }
    </script>
</body>
</html>
